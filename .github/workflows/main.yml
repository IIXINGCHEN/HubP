# 自动构建与发布流程
# 此工作流程支持三种触发方式：
# 1. push 到 main 分支：仅执行代码检查和构建测试，不推送标签、Docker 镜像或创建发布；
# 2. pull_request 到 main 分支：仅执行代码检查和构建测试，不推送标签、Docker 镜像或创建发布；
# 3. workflow_dispatch（手动触发）：执行版本号递增、标签推送、Docker 镜像构建与推送以及创建发布，
#    根据输入参数决定构建预发布（beta）或正式发布（release）。
name: 自动构建与发布流程

# 定义触发条件
on:
  # 当推送到 main 分支时触发，但忽略部分文件的变更
  push:
    branches: [ main ]
    paths-ignore:
      - '*.md'                    # 忽略所有 markdown 文件
      - 'docs/**'                 # 忽略文档目录
      - '.github/*.md'            # 忽略 GitHub 相关文档
      - 'LICENSE'                 # 忽略许可证文件
      - '.gitignore'              # 忽略 Git 忽略文件
      - '.editorconfig'           # 忽略编辑器配置
  # 当针对 main 分支发起 PR 时触发
  pull_request:
    branches: [ main ]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.github/*.md'
      - 'LICENSE'
      - '.gitignore'
      - '.editorconfig'
  # 手动触发工作流程
  workflow_dispatch:
    inputs:
      release_type:
        description: '发布类型 (beta=预发布, release=正式发布)'
        required: true
        default: 'beta'
        type: choice
        options:
          - beta     # 预发布版本
          - release  # 正式发布版本

# 配置全局权限
permissions:
  contents: write   # 允许创建发布和推送标签
  packages: write   # 允许推送到 GitHub Packages

# 全局环境变量设置
env:
  GO_VERSION: '1.22.0'             # 使用的 Go 版本
  BINARY_NAME: 'HubP'              # 项目生成的二进制文件名称
  DOCKER_IMAGE: 'hubp'             # Docker 镜像名称
  PLATFORMS: linux/amd64,linux/arm64  # Docker 构建支持的平台
  CGO_ENABLED: 0                   # 禁用 CGO，使用纯 Go 实现

jobs:
  # 版本控制任务
  # 用于获取最新 Git 标签，并在手动触发时对版本号递增、创建并推送新标签
  version:
    runs-on: ubuntu-latest
    outputs:
      # 将新版本号输出供其他任务使用
      new_version: ${{ steps.bump_version.outputs.new_version }}
      # 标识是否为手动触发（workflow_dispatch）
      is_manual_release: ${{ github.event_name == 'workflow_dispatch' }}
      # 标识是否为正式发布（手动触发且 release_type 为 release）
      is_release: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.release_type == 'release' }}
    steps:
      - name: 检出代码 📥
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # 获取完整提交历史，用于正确获取最新标签

      - name: 获取最新版本标签 🏷️
        id: get_latest
        run: |
          # 尝试获取最近的 Git 标签，如无则默认 v0.0.0
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "最新标签: ${latest_tag}"
          echo "latest_tag=${latest_tag}" >> $GITHUB_OUTPUT

      - name: 生成新版本号或使用现有版本号 📝
        id: bump_version
        shell: bash
        run: |
          # 从上一步获取最新标签
          latest_tag="${{ steps.get_latest.outputs.latest_tag }}"
          echo "当前获取的标签为: ${latest_tag}"
          # 如果为手动触发，则对版本号进行递增（仅递增修订号）
          if [ "$GITHUB_EVENT_NAME" == "workflow_dispatch" ]; then
            version="${latest_tag#v}"  # 去除 v 前缀
            # 将版本号按 . 分割为主版本、次版本和修订号
            IFS='.' read -r major minor patch <<< "$version"
            patch=${patch:-0}  # 若 patch 为空则默认 0
            patch=$((patch + 1))
            new_version="v${major}.${minor}.${patch}"
            echo "手动触发：生成新版本号: ${new_version}"
          else
            # 非手动触发时直接使用获取的最新标签
            new_version="${latest_tag}"
            echo "非手动触发：使用现有版本号: ${new_version}"
          fi
          echo "new_version=${new_version}" >> $GITHUB_OUTPUT

      - name: 手动触发时创建并推送新标签 📌
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          echo "配置 Git 用户信息..."
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          echo "创建标签: ${{ steps.bump_version.outputs.new_version }}"
          git tag -a ${{ steps.bump_version.outputs.new_version }} -m "Release ${{ steps.bump_version.outputs.new_version }}"
          echo "推送标签到远程仓库..."
          git push origin ${{ steps.bump_version.outputs.new_version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # 代码质量检查任务
  # 负责代码格式化、静态检查以及验证项目必要文件是否存在
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码 📥
        uses: actions/checkout@v4

      - name: 设置 Go 环境 🔧
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: 代码格式化与静态检查 🔍
        run: |
          if [ -f go.mod ]; then
            echo "执行 go fmt 格式化代码..."
            go fmt ./...
            echo "执行 go vet 进行静态检查..."
            go vet ./...
          else
            echo "警告：未找到 go.mod 文件，请检查项目结构！"
            exit 1
          fi

      - name: 检查项目必要文件 📂
        run: |
          # 验证 main.go 是否存在
          if [ ! -f "main.go" ]; then
            echo "错误：未找到 main.go 文件，请确保存在 main.go 作为项目入口！"
            exit 1
          fi
          # 验证 Dockerfile 是否存在
          if [ ! -f "Dockerfile" ]; then
            echo "错误：未找到 Dockerfile 文件，请确保存在用于构建镜像的 Dockerfile！"
            exit 1
          fi

  # 多平台构建任务
  # 负责编译项目、打包构建产物并生成校验和（用于测试验证）
  build:
    needs: [version, lint]  # 依赖版本控制和代码检查任务
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false   # 某个平台构建失败不影响其他平台
      matrix:
        # 定义目标操作系统和架构组合
        os: [linux, darwin, windows, freebsd]
        arch: [amd64, arm64]
    steps:
      - name: 检出代码 📥
        uses: actions/checkout@v4

      - name: 设置 Go 环境 🔧
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: 整理 Go 模块依赖 📦
        run: |
          echo "整理模块依赖..."
          go mod tidy
          echo "下载所有依赖包..."
          go mod download

      - name: 编译项目并打包构建产物 🏗️
        run: |
          # 获取版本号，若为空则报错
          VERSION=${{ needs.version.outputs.new_version }}
          if [ -z "$VERSION" ]; then
            echo "错误：未获取到版本号！"
            exit 1
          fi
          echo "构建版本: ${VERSION}"
          
          # 根据目标操作系统设置二进制文件名称（Windows 需要 .exe 后缀）
          binary_name="${{ env.BINARY_NAME }}"
          if [ "${{ matrix.os }}" = "windows" ]; then
            binary_name="${binary_name}.exe"
          fi
          
          # 创建存放构建产物的目录
          output_dir="release/${{ env.BINARY_NAME }}-${VERSION}-${{ matrix.os }}-${{ matrix.arch }}"
          mkdir -p "${output_dir}"
          
          echo "开始编译：操作系统=${{ matrix.os }}, 架构=${{ matrix.arch }}"
          # 设置环境变量进行编译，同时嵌入版本信息到二进制中
          GOOS=${{ matrix.os }} GOARCH=${{ matrix.arch }} \
          go build -trimpath \
            -ldflags="-s -w -X main.Version=${VERSION}" \
            -o "${output_dir}/${binary_name}" .
          
          # 切换到 release 目录，打包生成 zip 文件
          cd release
          zip_file="${{ env.BINARY_NAME }}-${VERSION}-${{ matrix.os }}-${{ matrix.arch }}.zip"
          echo "创建压缩包: ${zip_file}"
          zip -9 "${zip_file}" -r "$(basename ${output_dir})"/*
          
          # 生成该平台对应的校验和文件
          echo "生成校验和..."
          sha256sum "${zip_file}" | tee -a "checksums-${{ matrix.os }}-${{ matrix.arch }}.txt"
          
      - name: 上传构建产物作为构建结果 📤
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.os }}-${{ matrix.arch }}
          path: release/*
          retention-days: 1

  # Docker 构建任务（仅在手动触发时执行）
  # 根据发布类型构建并推送对应的 Docker 镜像：
  # - Beta 版本（预发布）：推送带有版本号和 beta 标签；
  # - 正式版本：推送带有版本号和 latest 标签。
  docker:
    needs: [version, lint]
    if: ${{ github.event_name == 'workflow_dispatch' }}  # 仅手动触发时执行 Docker 构建与推送
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码 📥
        uses: actions/checkout@v4

      - name: 设置 QEMU 模拟环境 🐳
        uses: docker/setup-qemu-action@v3

      - name: 设置 Docker Buildx 环境 🛠️
        uses: docker/setup-buildx-action@v3

      - name: 登录 Docker Hub 🔑
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 构建并推送 Beta 版本镜像（预发布版本）
      - name: 构建并推送 Beta 版本镜像 🚧
        if: ${{ needs.version.outputs.is_release != 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: ${{ env.PLATFORMS }}
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ needs.version.outputs.new_version }}
            ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:beta
          # 构建参数传入版本号和 Go 版本
          build-args: |
            VERSION=${{ needs.version.outputs.new_version }}
            GO_VERSION=${{ env.GO_VERSION }}

      # 构建并推送正式版本镜像（release 版本）
      - name: 构建并推送正式版本镜像 🚀
        if: ${{ needs.version.outputs.is_release == 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: ${{ env.PLATFORMS }}
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ needs.version.outputs.new_version }}
            ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:latest
          build-args: |
            VERSION=${{ needs.version.outputs.new_version }}
            GO_VERSION=${{ env.GO_VERSION }}

  # GitHub 发布任务（仅在手动触发时执行）
  # 下载所有构建产物，整合校验和，并生成发布说明后创建 GitHub 发布
  release:
    needs: [version, build, docker]
    if: ${{ github.event_name == 'workflow_dispatch' }}  # 仅手动触发时创建发布
    runs-on: ubuntu-latest
    steps:
      - name: 下载所有构建产物 📥
        uses: actions/download-artifact@v4
        with:
          path: release
          pattern: release-*
          merge-multiple: true

      - name: 准备发布文件和生成发布说明 📋
        run: |
          mkdir -p final_release
          echo "复制所有压缩包到 final_release 目录..."
          find release -name "*.zip" -exec cp {} final_release/ \;
          
          echo "整合各平台的校验和到一个文件中..."
          echo "## SHA256 校验和" > final_release/checksums.txt
          find release -name "checksums-*.txt" -exec cat {} >> final_release/checksums.txt \;
          
          # 根据是否为正式发布生成不同的发布说明
          {
            if [ "${{ needs.version.outputs.is_release }}" = "true" ]; then
              echo "# 🚀 正式发布版本 ${{ needs.version.outputs.new_version }}"
              echo ""
            else
              echo "# 🚧 预发布版本 ${{ needs.version.outputs.new_version }}"
              echo ""
            fi
            echo "## 📦 支持的平台"
            echo "- Linux (AMD64, ARM64)"
            echo "- macOS (AMD64, ARM64)"
            echo "- Windows (AMD64, ARM64)"
            echo "- FreeBSD (AMD64, ARM64)"
            echo ""
            echo "## 🐳 Docker 镜像说明"
            echo "支持的架构：AMD64, ARM64"
            echo ""
            echo "### 镜像获取方式"
            if [ "${{ needs.version.outputs.is_release }}" = "true" ]; then
              echo "- 使用最新稳定版: docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:latest"
              echo "- 使用指定版本: docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ needs.version.outputs.new_version }}"
            else
              echo "- 使用最新测试版: docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:beta"
              echo "- 使用指定版本: docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ needs.version.outputs.new_version }}"
            fi
            echo ""
            echo "## 校验和文件"
            cat final_release/checksums.txt
          } > final_release/release_notes.md

      - name: 创建 GitHub 发布版本 📢
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.version.outputs.new_version }}
          files: |
            final_release/*.zip
            final_release/checksums.txt
          body_path: final_release/release_notes.md
          draft: false
          # 如果不是正式发布则标记为预发布
          prerelease: ${{ needs.version.outputs.is_release != 'true' }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
